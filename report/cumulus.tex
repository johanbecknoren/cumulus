\documentclass[11pt,twocolumn]{article}
\usepackage{graphicx,url,placeins,algorithm,subcaption, algorithmic,lipsum,amssymb,amsmath,float}
\usepackage[hidelinks]{hyperref}
\usepackage[titletoc]{appendix}
\usepackage{pdfpages}
\usepackage{listings}

\usepackage{breqn}

 %\renewcommand{\familydefault}{\sfdefault}

\usepackage{natbib}

\makeatletter
\let\@texttop\relax
\makeatother
\topmargin-0.32in
\textheight22.2cm

\usepackage{layout}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[utf8]{inputenc}
\graphicspath{{figures/}}
\setlength{\voffset}{0in}
\setlength{\headsep}{1pt}
\addtolength{\textheight}{2cm}
%\setlength{\footskip}{5pt}
%
\begin{document}
\title{\vskip -2em Cumulus}   % type title between braces
\author{Andreas Valter, andva287@student.liu.se}
\date{\today}    % type date between braces
\maketitle
\begingroup
% \let\clearpage\relax % Removes blank page before include

\begin{abstract}

\end {abstract}

\section{Background}
Real time rendering is something that has been almost exclusive to game development where new games demands a higher quality to convince gamers to buy that game, instead of others.
This industy leads to a demand for better computer components that allows the games to run smoothly which leads to a decrease in cost for these components as the demand goes up.
This results in cheap and fast components, highly tuned for the computations that games does.
Other industries that faces similar problems can reap the benefits and this is something that is especially applicable for the visual effects (VFX) industry.

The general workflow for a VFX company is to create scenes with models that are interacting with each other and real people.
While working the artists handles simple place holders that represents the final output and when they think they are done, they push the work to a rendering farm for rendering.
To render a scene takes time, these super computers needs to calculate how the light interacts in the scene, resulting in a high quality estimation of how the scene looks.
But the interface that the artists are working with is often of much less quality then the final output, something that moves testing from the local computer to the farm.
This would lead to a real time output for changes made to simulations and models.

Therefore a lot of resent research has been aimed at moving work from the CPU that is not optimized for graphics computations to the GPU which converts application from offline to real time rendering.

\subsection{Viewport 2.0}


\subsection{Ray Marching}
A volume data set is simply numbers representing density values at some point in the volume space.
In our implementation the volume data is stored as a 3D texture.
Together with GLSL shaders this allows for the use of fast hardware trilinear interpolation of values for arbitrary points within the volume. To determine the final color for a pixel on the screen we use ray marching to sample the volume.
The most simple case is a volume set aligned with the camera viewing direction.
This would only require samples to be taken along a ray aligned with the volume axes.
Density values in the volume are sampled along the ray at sample points with a uniform spacing and the final density for the pixel is a sum of all the sampled density values.
This is the implementation we used in this project.
\\
A method to allow for interactive camera positioning around the volume is a method using a color cube.
A uniform cube is rendered first using front face culling and then using back face culling.
For each pixel its position is stored in a frame buffer object in a first rendering pass.
For the volume rendering pass these framebuffers are used to determine a ray direction by comparing the values stored in the front face and back face textures for each pixel. From this we get a ray origin and a direction, which is then used to sample the volume in the same uniform fashion as described in the previous paragraph.

\section{Implementation}

\section{Summary}


\endgroup
\newpage
\bibliographystyle{abbrv}
\nocite{*}
\bibliography{bibl}

\end{document}